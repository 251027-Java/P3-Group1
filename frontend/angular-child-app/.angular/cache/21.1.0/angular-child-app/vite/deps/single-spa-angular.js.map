{
  "version": 3,
  "sources": ["../../../../../../node_modules/single-spa-angular/fesm2022/single-spa-angular-internals.mjs", "../../../../../../node_modules/single-spa-angular/fesm2022/single-spa-angular.mjs"],
  "sourcesContent": ["function getContainerElementAndSetTemplate(options, props) {\n    const domElementGetter = chooseDomElementGetter(options, props);\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !domElementGetter) {\n        throw Error(`Cannot mount angular application '${props.name || props.appName}' without a domElementGetter provided either as an opt or a prop`);\n    }\n    const containerElement = getContainerElement(domElementGetter, props);\n    containerElement.innerHTML = options.template;\n    return containerElement;\n}\nfunction getContainerElement(domElementGetter, props) {\n    const element = domElementGetter(props);\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !element) {\n        throw Error('domElementGetter did not return a valid dom element');\n    }\n    return element;\n}\nfunction chooseDomElementGetter(opts, props) {\n    props = props?.customProps ?? props;\n    if (props.domElement) {\n        return () => props.domElement;\n    }\n    else if (props.domElementGetter) {\n        return props.domElementGetter;\n    }\n    else if (opts.domElementGetter) {\n        return opts.domElementGetter;\n    }\n    else {\n        return defaultDomElementGetter(props.name);\n    }\n}\nfunction defaultDomElementGetter(name) {\n    return function getDefaultDomElement() {\n        const id = `single-spa-application:${name}`;\n        let domElement = document.getElementById(id);\n        if (!domElement) {\n            domElement = document.createElement('div');\n            domElement.id = id;\n            document.body.appendChild(domElement);\n        }\n        return domElement;\n    };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { getContainerElementAndSetTemplate };\n\n", "import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\nimport { BrowserPlatformLocation, DOCUMENT, PlatformLocation } from '@angular/common';\nfunction enableProdMode() {\n  try {\n    // The `enableProdMode` will throw an error if it's called multiple times,\n    // but it may be called multiple times when dependencies are shared.\n    i0.enableProdMode();\n  } catch {\n    // Nothing to do here.\n  }\n}\nclass SingleSpaPlatformLocation extends BrowserPlatformLocation {\n  constructor() {\n    super(...arguments);\n    // This is a simple marker that helps us to ignore PopStateEvents\n    // that was not dispatched by the browser.\n    this.skipNextPopState = false;\n    this.source = 'Window.addEventListener:popstate';\n  }\n  pushState(state, title, url) {\n    this.skipNextPopState = true;\n    super.pushState(state, title, url);\n  }\n  replaceState(state, title, url) {\n    this.skipNextPopState = true;\n    super.replaceState(state, title, url);\n  }\n  onPopState(fn) {\n    // `Zone.current` will reference the zone that serves as an execution context\n    // to some specific application, especially when `onPopState` is called.\n    const zone = Zone.current;\n    // Wrap any event listener into zone that is specific to some application.\n    // The main issue is `back/forward` buttons of browsers, because they invoke\n    // `history.back|forward` which dispatch `popstate` event. Since `single-spa`\n    // overrides `history.replaceState` Angular's zone cannot intercept this event.\n    // Only the root zone is able to intercept all events.\n    // See https://github.com/single-spa/single-spa-angular/issues/94 for more details\n    fn = zone.wrap(fn, this.source);\n    const onPopStateListener = event => {\n      // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added\n      // by `single-spa` starting from `5.4` version. We need this check because we want\n      // to skip \"unnatural\" PopStateEvents, the one caused by `single-spa`.\n      const popStateEventWasDispatchedBySingleSpa = !!event.singleSpa;\n      if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {\n        this.skipNextPopState = false;\n      } else {\n        fn(event);\n      }\n    };\n    return super.onPopState(onPopStateListener);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵSingleSpaPlatformLocation_BaseFactory;\n      return function SingleSpaPlatformLocation_Factory(__ngFactoryType__) {\n        return (ɵSingleSpaPlatformLocation_BaseFactory || (ɵSingleSpaPlatformLocation_BaseFactory = i0.ɵɵgetInheritedFactory(SingleSpaPlatformLocation)))(__ngFactoryType__ || SingleSpaPlatformLocation);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SingleSpaPlatformLocation,\n      factory: SingleSpaPlatformLocation.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SingleSpaPlatformLocation, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * The `PlatformLocation` class is an \"injectee\" of the `PathLocationStrategy`,\n * which creates `Subject` internally for listening on `popstate` events. We want\n * to provide this class in the most top injector that's used during bootstrapping.\n */\nfunction getSingleSpaExtraProviders() {\n  return [{\n    provide: SingleSpaPlatformLocation,\n    deps: [[new Inject(DOCUMENT)]]\n  }, {\n    provide: PlatformLocation,\n    useExisting: SingleSpaPlatformLocation\n  }];\n}\nconst defaultOptions = {\n  // Required options that will be set by the library consumer.\n  NgZone: null,\n  bootstrapFunction: null,\n  template: null,\n  // Optional options\n  Router: undefined,\n  domElementGetter: undefined,\n  // only optional if you provide a domElementGetter as a custom prop\n  updateFunction: () => Promise.resolve(),\n  bootstrappedNgModuleRefOrAppRef: null\n};\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nfunction singleSpaAngular(userOptions) {\n  if (NG_DEV_MODE && typeof userOptions !== 'object') {\n    throw Error('single-spa-angular requires a configuration object');\n  }\n  const options = {\n    ...defaultOptions,\n    ...userOptions\n  };\n  if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {\n    throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n  }\n  if (NG_DEV_MODE && typeof options.template !== 'string') {\n    throw Error('single-spa-angular must be passed options.template string');\n  }\n  if (NG_DEV_MODE && !options.NgZone) {\n    throw Error(`single-spa-angular must be passed the NgZone option`);\n  }\n  if (NG_DEV_MODE && options.Router && !options.NavigationStart) {\n    // We call `console.warn` except of throwing `new Error()` since this will not\n    // be a breaking change.\n    console.warn(`single-spa-angular must be passed the NavigationStart option`);\n  }\n  return {\n    bootstrap: bootstrap.bind(null, options),\n    mount: mount.bind(null, options),\n    unmount: unmount.bind(null, options),\n    update: options.updateFunction\n  };\n}\nasync function bootstrap(options) {\n  // Angular provides an opportunity to develop `zone-less` application, where developers\n  // have to trigger change detection manually.\n  // See https://angular.io/guide/zone#noopzone\n  if (options.NgZone === 'noop') {\n    return;\n  }\n  // Note that we have to make it a noop function because it's a static property and not\n  // an instance property. We're unable to configure it for multiple apps when dependencies\n  // are shared and reference the same `NgZone` class. We can't determine where this function\n  // is being executed or under which application, making it difficult to assert whether this\n  // app is running under its zone.\n  options.NgZone.assertInAngularZone = () => {};\n  options.NgZone.assertNotInAngularZone = () => {};\n  options.routingEventListener = () => {\n    options.bootstrappedNgZone.run(() => {\n      // See https://github.com/single-spa/single-spa-angular/issues/86\n      // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n      // unless we tell Zone that something happened\n    });\n  };\n}\nasync function mount(options, props) {\n  getContainerElementAndSetTemplate(options, props);\n  const bootstrapPromise = options.bootstrapFunction(props);\n  if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {\n    throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);\n  }\n  const ngModuleRefOrAppRef = await bootstrapPromise;\n  if (NG_DEV_MODE) {\n    if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {\n      throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);\n    }\n  }\n  const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);\n  const ngZoneEnabled = options.NgZone !== 'noop';\n  // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n  // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n  // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n  // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n  if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n    throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n  }\n  const bootstrappedOptions = options;\n  if (ngZoneEnabled) {\n    const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);\n    // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n    // function was not called.\n    if (singleSpaPlatformLocation !== null) {\n      skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);\n    }\n    bootstrappedOptions.bootstrappedNgZone = ngZone;\n    window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);\n  }\n  bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;\n  return ngModuleRefOrAppRef;\n}\nfunction unmount(options) {\n  return Promise.resolve().then(() => {\n    if (options.routingEventListener) {\n      window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n    }\n    options.bootstrappedNgModuleRefOrAppRef.destroy();\n    options.bootstrappedNgModuleRefOrAppRef = null;\n  });\n}\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {\n  if (!options.NavigationStart) {\n    // As discussed we don't do anything right now if the developer doesn't provide\n    // `options.NavigationStart` since this might be a breaking change.\n    return;\n  }\n  const router = ngModuleRefOrAppRef.injector.get(options.Router);\n  const subscription = router.events.subscribe(event => {\n    if (event instanceof options.NavigationStart) {\n      const currentNavigation = router.getCurrentNavigation();\n      // This listener will be set up for each Angular application\n      // that has routing capabilities.\n      // We set `skipLocationChange` for each non-imperative navigation,\n      // Angular router checks under the hood if it has to change\n      // the browser URL or not.\n      // If `skipLocationChange` is truthy then Angular router will not call\n      // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n      if (currentNavigation.trigger !== 'imperative') {\n        currentNavigation.extras.skipLocationChange = true;\n        currentNavigation.extras.replaceUrl = false;\n      }\n    }\n  });\n  ngModuleRefOrAppRef.onDestroy(() => subscription.unsubscribe());\n}\n\n/**\n * The public api for consumers of single-spa-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { enableProdMode, getSingleSpaExtraProviders, singleSpaAngular };\n"],
  "mappings": "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",
  "names": ["enableProdMode"]
}
