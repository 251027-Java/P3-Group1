pipeline {
    agent any

    parameters {
        string(name: 'BRANCH', defaultValue: 'main', description: 'Branch to build')
    }

    environment {
        SERVICE_NAME = 'react-spring-backend'
        SERVICE_PATH = 'backend/React-spring-backend'
        // Use a local tag name since you are deploying on the same machine
        DOCKER_IMAGE = "local/${SERVICE_NAME}"
        SONAR_PROJECT_KEY = "${SERVICE_NAME}"
        // Matches service name in root docker-compose.yml
        COMPOSE_SERVICE_NAME = 'react-backend'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout([$class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: 'your-repo-url']]
                ])
            }
        }

        stage('Build & Test') {
            steps {
                dir("${SERVICE_PATH}") {
                    script {
                        echo "Building and Testing ${SERVICE_NAME}..."
                        // 'package' creates the .jar file needed for the Docker image
                        sh 'mvn clean package' 
                        
                        junit '**/target/surefire-reports/*.xml'
                        jacoco(
                            execPattern: '**/target/jacoco.exec',
                            classPattern: '**/target/classes',
                            sourcePattern: '**/src/main/java'
                        )
                    }
                }
            }
        }

        stage('Static Analysis') {
            steps {
                dir("${SERVICE_PATH}") {
                    withSonarQubeEnv('SonarQube') {
                        sh "mvn sonar:sonar -Dsonar.projectKey=${SONAR_PROJECT_KEY}"
                    }
                }
            }
        }

        stage('Quality Gate') {
            steps {
                timeout(time: 5, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        stage('Local Deploy') {
            when { branch 'main' }
            steps {
                dir("${SERVICE_PATH}") {
                    script {
                        echo "Deploying via Docker Compose (Root)..."
                        // Using root docker-compose.yml because the local one only contains Postgres
                        // and we need Kafka/Eureka dependencies defined in the root compose.
                        sh "docker-compose -f ../../docker-compose.yml up --build -d ${COMPOSE_SERVICE_NAME}"
                    }
                }
            }
        }
    }

    post {
        always {
            // Clean workspace to save disk space
            cleanWs()
        }
        success {
            echo "Successfully deployed ${SERVICE_NAME} to local environment!"
        }
    }
}